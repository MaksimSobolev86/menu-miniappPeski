
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Меню</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body, #root {
      height: 100%;
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    body {
        background-color: transparent;
    }
    .antialiased {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .no-scrollbar::-webkit-scrollbar {
        display: none;
    }
    .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
  </style>
</head>
<body class="antialiased text-sm">
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useCallback, useMemo } from 'https://esm.sh/react@18.2.0';
    import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';

    // --- CONSTANTS ---
    const SHEET_URL = "https://opensheet.elk.sh/1L_ymP4fcpKC-oMuMqDLK1SVMGTnPCtWaSM0fOKW8KJw/menu";
    const CATEGORIES = {
      "казан": "Казан",
      "граммы": "Мангал",
      "досуг": "Досуг",
      "меню": "Банкетное меню"
    };

    // --- UTILS ---
    const htmlEscape = (str) =>
      (str || "").replace(/&/g, "&amp;").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    const formatDescription = (text) =>
      (text || "").trim().replace(/(^|\n)([\p{Emoji_Presentation}\p{Extended_Pictographic}])/gu, '$1<br>$2').replace(/•/g, '<br>•').replace(/\n+/g, '<br>').replace(/(<br>\s*){2,}/g, '<br><br>');
    const truncate = (text, maxLength = 80) => {
      if (!text) return "";
      const cleanedText = text.replace(/<[^>]+>/g, "");
      return cleanedText.length > maxLength ? cleanedText.slice(0, maxLength).trim() + "…" : text;
    }
    const normalizeImage = (url) => {
      if (!url) return "";
      const trimmedUrl = url.trim();
      if (trimmedUrl.includes("drive.google.com")) {
        const match = trimmedUrl.match(/\/d\/([a-zA-Z0-9_-]+)/);
        if (match) return `https://drive.google.com/uc?export=view&id=${match[1]}`;
      }
      return trimmedUrl;
    };
    const calculateTotal = (qty, price, unit, customPriceJson) => {
      if (unit === "гр") return (qty / 100) * price;
      if (customPriceJson) {
        try {
          const priceMap = JSON.parse(customPriceJson);
          const qtyKey = qty.toString();
          if (priceMap[qtyKey] !== undefined) return priceMap[qtyKey];
        } catch (e) {
          console.warn("Invalid custom price JSON:", customPriceJson);
        }
      }
      return qty * price;
    };

    // --- TELEGRAM SERVICE ---
    const getTelegram = () => {
        if (typeof window !== 'undefined' && window.Telegram && window.Telegram.WebApp) {
            return window.Telegram.WebApp;
        }
        return null;
    };
    const tg = getTelegram();
    const telegramService = {
        init: () => {
            try {
                tg?.ready();
                tg?.expand();
                tg?.enableClosingConfirmation();
            } catch (e) {
                console.warn("Telegram WebApp SDK not found or failed to initialize.");
            }
        },
        sendData: (data) => {
            try {
                const payload = {
                    ...data,
                    telegram_id: tg?.initDataUnsafe?.user?.id || null,
                };
                tg?.sendData(JSON.stringify(payload));
                tg?.close();
            } catch (e) {
                console.error("Failed to send data via Telegram:", e);
                alert("Не удалось отправить заказ. Пожалуйста, попробуйте еще раз.");
            }
        },
        triggerHapticFeedback: (style) => {
            try {
                tg?.HapticFeedback.impactOccurred(style);
            } catch (e) {
                // Fails silently
            }
        },
        isTelegramEnv: !!tg,
    };

    // --- COMPONENTS ---
    const Icon = ({ name, className = 'w-6 h-6' }) => {
        switch (name) {
            case 'cart':
                return <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z" /></svg>;
            case 'trash':
                return <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>;
            case 'calendar':
                return <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3h-1V2h-2v1H8V2H6v1H5c-1.1 0-2 .9-2 2v15c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 17H5V8h14v12z"/></svg>;
            case 'close':
                return <svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2.5"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>;
            default:
                return null;
        }
    };
    
    const CardSkeleton = () => {
        return (
            <div className="flex items-start bg-white/80 rounded-xl p-4 gap-4 backdrop-blur-sm animate-pulse">
                <div className="w-16 h-16 sm:w-20 sm:h-20 rounded-xl bg-gray-300 flex-shrink-0"></div>
                <div className="flex-1 space-y-3">
                    <div className="h-5 bg-gray-300 rounded w-3/4"></div>
                    <div className="h-4 bg-gray-300 rounded w-full"></div>
                    <div className="h-8 bg-gray-300 rounded w-28 mt-4"></div>
                </div>
            </div>
        );
    };

    const Card = ({ item, onAddToCart, onViewDetails, onViewBanquetMenu }) => {
        const { id, name, type, description, price, unit, photos } = item;
        const isBanquetMenu = type === 'меню' || name.toLowerCase().includes('банкет');
        const isLeisure = type === 'досуг';

        const shortDescription = truncate(description);
        const formattedShortDescription = formatDescription(htmlEscape(shortDescription));

        const media = type === "меню"
            ? <div className="bg-gray-100 flex items-center justify-center w-16 h-16 sm:w-20 sm:h-20 rounded-xl mr-2 sm:mr-4 flex-shrink-0"><Icon name="calendar" className="w-8 h-8 sm:w-10 sm:h-10 text-gray-500" /></div>
            : <img src={photos[0] || `https://picsum.photos/seed/${id}/80`} alt={htmlEscape(name)} className="w-16 h-16 sm:w-20 sm:h-20 rounded-xl object-cover mr-2 sm:mr-4 flex-shrink-0" loading="lazy"/>;

        const baseBtn = "px-4 py-2.5 rounded-lg text-sm sm:text-base font-semibold transition-colors flex items-center justify-center";
        const smallBtn = "px-3 py-2 rounded-lg text-xs sm:text-sm font-semibold transition-colors flex items-center justify-center";
        
        let buttons;
        if (isBanquetMenu) {
            buttons = <button onClick={() => onViewBanquetMenu(item)} className={`${baseBtn} bg-yellow-500 hover:bg-yellow-600 text-white`}>Посмотреть</button>;
        } else if (isLeisure) {
            buttons = (
                <React.Fragment>
                    <button onClick={() => onViewDetails(item)} className={`${smallBtn} bg-yellow-500 hover:bg-yellow-600 text-white`}>Посмотреть</button>
                    <button onClick={() => onAddToCart(item)} className={`${smallBtn} bg-blue-500 hover:bg-blue-600 text-white`}>
                        <Icon name="cart" className="h-4 w-4 mr-1 sm:mr-1.5" /> Добавить
                    </button>
                </React.Fragment>
            );
        } else {
            buttons = (
                <button onClick={() => onAddToCart(item)} className={`${baseBtn} bg-blue-500 hover:bg-blue-600 text-white`}>
                    <Icon name="cart" className="h-4 w-4 sm:h-5 sm:w-5 mr-1.5" /> Добавить
                </button>
            );
        }
        
        return (
            <div className="flex items-start bg-white/90 rounded-xl p-3 sm:p-4 gap-3 sm:gap-4 backdrop-blur-sm">
                {media}
                <div className="flex-1">
                    <h3 className="font-semibold text-base sm:text-lg mb-1 text-gray-900">{htmlEscape(name)}</h3>
                    {shortDescription && <div className="text-gray-500 text-xs sm:text-sm mb-2" dangerouslySetInnerHTML={{ __html: formattedShortDescription }} />}
                    {!isBanquetMenu && (
                        <div className="mb-3 text-base sm:text-lg font-semibold text-black">
                            {price} ₽ {unit && <span className="text-xs sm:text-sm font-normal text-gray-600">/ {unit}</span>}
                        </div>
                    )}
                    <div className="flex items-center flex-wrap gap-2">{buttons}</div>
                </div>
            </div>
        );
    };

    const Modal = ({ item, onClose }) => {
        useEffect(() => {
            const handleEsc = (event) => {
                if (event.key === 'Escape') onClose();
            };
            window.addEventListener('keydown', handleEsc);
            return () => window.removeEventListener('keydown', handleEsc);
        }, [onClose]);
        
        useEffect(() => {
            document.body.style.overflow = item ? 'hidden' : 'unset';
            return () => { document.body.style.overflow = 'unset'; }
        }, [item]);

        if (!item) return null;

        const formattedHtml = formatDescription(htmlEscape(item.description));
        const imagesHtml = item.photos.map(url => `<img src="${url}" class="w-full h-auto rounded-xl object-cover mt-4" alt="Фото" loading="lazy"/>`).join('');
        const finalContent = `<div class="whitespace-pre-wrap text-base text-gray-700 leading-relaxed">${formattedHtml}</div><div class="mt-4 space-y-4">${imagesHtml}</div>`;

        return (
            <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 transition-opacity duration-300 ease-in-out" onClick={onClose}>
                <div className="relative bg-white rounded-2xl max-w-md w-full m-4 flex flex-col" style={{ maxHeight: '90vh' }} onClick={e => e.stopPropagation()}>
                    <header className="sticky top-0 bg-white/80 backdrop-blur-md p-4 flex items-center justify-between border-b border-gray-200 z-10 rounded-t-2xl">
                        <h3 className="font-bold text-lg text-gray-900 truncate pr-4">{htmlEscape(item.name)}</h3>
                        <button onClick={onClose} className="p-2 rounded-full text-gray-500 hover:bg-gray-200 hover:text-gray-900 transition-colors flex-shrink-0" aria-label="Закрыть">
                            <Icon name="close" />
                        </button>
                    </header>
                    <div className="overflow-y-auto px-6 py-4" dangerouslySetInnerHTML={{ __html: finalContent }} />
                </div>
            </div>
        );
    };

    const Cart = ({ items, onRemove, onConfirm }) => {
        const total = useMemo(() => {
            return items.reduce((sum, item) => sum + calculateTotal(item.qty, item.price, item.unit, item.customPriceJson), 0);
        }, [items]);

        if (items.length === 0) return null;

        return (
            <div className="fixed bottom-0 left-0 right-0 z-40">
                <div className="bg-white p-4 border-t border-gray-200">
                    <div className="max-w-4xl mx-auto">
                        <h2 className="font-bold text-lg sm:text-xl mb-3 px-2 text-gray-900">Корзина</h2>
                        <div id="cart-items" className="text-xs text-gray-800 space-y-3 px-2 max-h-[150px] overflow-y-auto no-scrollbar">
                            {items.map((item, index) => (
                                <div key={`${item.id}-${index}`} className="flex justify-between items-center">
                                    <div className="flex-1">
                                        <span className="font-semibold">{htmlEscape(item.name)}</span>
                                        <span className="text-gray-600"> × {item.qty} {item.unit || ""} — {calculateTotal(item.qty, item.price, item.unit, item.customPriceJson).toFixed(0)} ₽</span>
                                    </div>
                                    <button onClick={() => onRemove(index)} className="text-red-500 w-9 h-9 flex items-center justify-center" aria-label="Удалить товар">
                                        <Icon name="trash" className="h-5 w-5" />
                                    </button>
                                </div>
                            ))}
                        </div>
                        <div className="pt-4 mt-2 border-t border-gray-200">
                            <div className="flex justify-between items-center px-2 mb-4">
                                <span className="text-base sm:text-lg font-semibold text-gray-900">Итого:</span>
                                <span className="text-xl sm:text-2xl font-bold text-black">{total.toFixed(0)} ₽</span>
                            </div>
                            <button onClick={onConfirm} className="bg-green-600 text-white text-base sm:text-lg w-full py-3 sm:py-3.5">
                                Подтвердить заказ
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    const Header = ({ activeTab, onTabClick, visibleCategories }) => {
        return (
            <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md">
                <div className="max-w-4xl mx-auto px-4 sm:px-6">
                    <div className="flex items-center justify-between pt-4 pb-3">
                        <h1 className="text-xl sm:text-2xl font-bold text-gray-900">Меню</h1>
                    </div>
                    <nav className="flex gap-6 pb-3 overflow-x-auto whitespace-nowrap no-scrollbar">
                        {visibleCategories.map((key) => {
                            const isActive = activeTab === key;
                            return (
                                <button
                                    key={key}
                                    onClick={() => onTabClick(key)}
                                    className={`py-2 text-xl font-bold transition-colors duration-300 ${isActive ? 'text-gray-900' : 'text-gray-500 hover:text-gray-900'}`}
                                >
                                    {CATEGORIES[key]}
                                </button>
                            )
                        })}
                    </nav>
                </div>
            </header>
        );
    };

    // --- MAIN APP ---
    function App() {
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState(null);
        const [groupedItems, setGroupedItems] = useState({ казан: [], граммы: [], досуг: [], меню: [] });
        const [activeTab, setActiveTab] = useState('казан');
        const [cart, setCart] = useState([]);
        const [selectedItem, setSelectedItem] = useState(null);

        useEffect(() => {
            telegramService.init();
        }, []);

        const fetchData = useCallback(async () => {
            setIsLoading(true);
            setError(null);
            try {
                const response = await fetch(SHEET_URL);
                if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                const data = await response.json();

                const newGroupedItems = { казан: [], граммы: [], досуг: [], меню: [] };

                data.forEach((item, index) => {
                    const typeRaw = (item.Тип || "").trim().toLowerCase();
                    if (Object.keys(CATEGORIES).includes(typeRaw)) {
                        const type = typeRaw;
                        const photos = (item.Фото || "").split(",").map(url => normalizeImage(url)).filter(Boolean);
                        const step = parseFloat(item["Шаг"] || '1');
                        const minQtyRaw = parseFloat(item["Мин"] || '0');
                        const processedItem = {
                            id: `${type}-${index}-${(item.Название || '').replace(/\s/g, '')}`,
                            name: item.Название || 'Без названия',
                            type: type,
                            description: item.Описание || '',
                            price: parseFloat(item.Цена) || 0,
                            unit: item["Ед. изм."]?.trim() || '',
                            step: isNaN(step) || step <= 0 ? 1 : Math.round(step * 10) / 10,
                            minQty: isNaN(minQtyRaw) || minQtyRaw <= 0 ? (isNaN(step) || step <= 0 ? 1 : Math.round(step * 10) / 10) : Math.round(minQtyRaw * 10) / 10,
                            photos: photos,
                            customPriceJson: item["Цена JSON"]?.trim() || ''
                        };
                        newGroupedItems[type].push(processedItem);
                    }
                });
                setGroupedItems(newGroupedItems);
            } catch (e) {
                console.error("Failed to fetch menu data:", e);
                setError("Не удалось загрузить меню. Попробуйте позже.");
            } finally {
                setIsLoading(false);
            }
        }, []);

        useEffect(() => {
            fetchData();
        }, [fetchData]);

        const handleTabClick = (key) => setActiveTab(key);

        const handleAddToCart = (item) => {
            telegramService.triggerHapticFeedback('light');
            setCart(prevCart => {
                const existingIndex = prevCart.findIndex(cartItem => cartItem.id === item.id);
                if (existingIndex > -1) {
                    const newCart = [...prevCart];
                    const newQty = newCart[existingIndex].qty + item.step;
                    newCart[existingIndex].qty = Math.round(newQty * 10) / 10;
                    return newCart;
                } else {
                    return [...prevCart, { id: item.id, name: item.name, qty: item.minQty, price: item.price, unit: item.unit, customPriceJson: item.customPriceJson }];
                }
            });
        };

        const handleRemoveFromCart = (index) => {
            telegramService.triggerHapticFeedback('light');
            setCart(prevCart => prevCart.filter((_, i) => i !== index));
        };
        
        const handleConfirmOrder = () => {
            if (cart.length === 0) return;
            telegramService.triggerHapticFeedback('medium');
            const payload = {
                items: cart.map(c => ({
                    name: c.name, qty: c.qty, unit: c.unit,
                    price: c.unit === 'гр' ? c.price / 100 : c.price,
                    total: calculateTotal(c.qty, c.price, c.unit, c.customPriceJson),
                })),
                total: cart.reduce((sum, c) => sum + calculateTotal(c.qty, c.price, c.unit, c.customPriceJson), 0),
            };
            telegramService.sendData(payload);
        };
        
        const handleViewDetails = (item) => setSelectedItem(item);
        const handleCloseModal = () => setSelectedItem(null);
        
        const handleViewBanquetMenu = (item) => {
            const photoUrl = item.photos[0] || '';
            if (!photoUrl) {
                alert("Ссылка на меню не найдена.");
                return;
            };
            const rawUrl = photoUrl.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/");
            window.open(rawUrl, "_blank");
        };

        const visibleCategories = useMemo(() => {
            return Object.keys(CATEGORIES).filter(key => groupedItems[key] && groupedItems[key].length > 0);
        }, [groupedItems]);

        const mainPaddingBottom = useMemo(() => cart.length > 0 ? 'pb-56' : 'pb-4', [cart]);

        return (
            <div className="min-h-full text-gray-900 bg-f0f2f5">
                <div style={{backgroundImage: "url('https://raw.githubusercontent.com/MaksimSobolev86/menu-miniappPeski/main/bakground.png')"}} 
                     className="fixed inset-0 bg-center bg-cover -z-20">
                </div>
                <Header 
                    activeTab={activeTab} 
                    onTabClick={handleTabClick}
                    visibleCategories={visibleCategories}
                />
                <main className={`px-4 sm:px-6 py-4 max-w-4xl mx-auto transition-all duration-300 ease-out ${mainPaddingBottom}`}>
                    {error && <div className="text-center py-10 text-red-500 bg-white/80 rounded-lg p-4 font-semibold">{error}</div>}
                    <div className="space-y-4">
                        {isLoading ? (
                            Array.from({ length: 5 }).map((_, i) => <CardSkeleton key={i} />)
                        ) : (
                            groupedItems[activeTab]?.map((item) => (
                                <Card 
                                    key={item.id} 
                                    item={item}
                                    onAddToCart={handleAddToCart}
                                    onViewDetails={handleViewDetails}
                                    onViewBanquetMenu={handleViewBanquetMenu}
                                />
                            ))
                        )}
                    </div>
                </main>
                <Cart items={cart} onRemove={handleRemoveFromCart} onConfirm={handleConfirmOrder} />
                <Modal item={selectedItem} onClose={handleCloseModal} />
            </div>
        );
    }

    // --- RENDER APP ---
    const rootElement = document.getElementById('root');
    const root = ReactDOM.createRoot(rootElement);
    root.render(<App />);

  </script>
</body>
</html>
